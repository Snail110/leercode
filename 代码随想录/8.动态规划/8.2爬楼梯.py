"""
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1 阶 + 1 阶
2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1 阶 + 1 阶 + 1 阶
1 阶 + 2 阶
2 阶 + 1 阶

我们来分析一下，动规五部曲：

定义一个一维数组来记录不同楼层的状态

确定dp数组以及下标的含义
dp[i]： 爬到第i层楼梯，有dp[i]种方法

确定递推公式
如果可以推出dp[i]呢？

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以dp[i] = dp[i - 1] + dp[i - 2] 。

在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。

这体现出确定dp数组以及下标的含义的重要性！
dp数组如何初始化
我相信dp[1] = 1，dp[2] = 2，

确定遍历顺序
从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的

举例推导dp数组
举例当n为5的时候，dp table（dp数组）应该是这样的

"""

class Solution:
    def sumFloor(self,N:int):
        if N<=1:
            return N
        # 确定dp数组
        dp = [0] * (N+1)
        # 初始化
        dp[1] = 1
        dp[2] = 2
        # 遍历顺序 注意从3开始 并且 需要遍历到N+1
        for i in range(3,N+1,1):
            # 递推公式
            dp[i] = dp[i-1] + dp[i-2]

        return dp[N]

s = Solution()
N = 3
print(s.sumFloor(4))